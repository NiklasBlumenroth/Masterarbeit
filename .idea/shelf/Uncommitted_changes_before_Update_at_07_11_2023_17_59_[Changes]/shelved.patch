Index: src/main/java/Nutzwertanalyse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import Enums.FuzzyJudgements;\r\nimport Enums.FuzzyPreferenzes;\r\nimport Enums.LexJudgements;\r\nimport Enums.LexPreferenzes;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\nimport static Enums.LexPreferenzes.*;\r\nimport static Enums.LexJudgements.*;\r\n\r\npublic class Nutzwertanalyse {\r\n    public static final int alt = 4;\r\n    public static final int crit = 5;\r\n    public static final int numberOfDecisionMaker = 4;\r\n    public static final Class jugClazz = LexJudgements.class;\r\n    public static final Class prefClazz = LexPreferenzes.class;\r\n    public static final boolean full = true;\r\n    public static final boolean show = false;\r\n\r\n    public static ArrayList<Object>[][] getMatrix() {\r\n//        return new ArrayList[][]{\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}},\r\n//                        new ArrayList<>(){{add(MG); add(VG);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(VG);}},\r\n//                        new ArrayList<>(){{add(F); add(MG);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MG); add(P); add(VG);}},\r\n//                        new ArrayList<>(){{add(G); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(P);}}\r\n//                }\r\n//        };\r\n\r\n        return new ArrayList[][]{\r\n                {\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);}},\r\n                        new ArrayList<>() {{add(JB);}},\r\n                        new ArrayList<>() {{add(JC);}},\r\n                        new ArrayList<>() {{add(JA);}}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(JA);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);add(JC);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);add(JC);}},\r\n                        new ArrayList<>() {{add(JB);}},\r\n                        new ArrayList<>() {{add(JB);add(JC);}},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                            add(JC);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JC);\r\n                        }},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                            add(JC);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JC);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }}\r\n                }\r\n        };\r\n    }\r\n\r\n    public static ArrayList<Object>[] getWeights() {\r\n//        return new ArrayList[]{\r\n//                new ArrayList<>(){{add(H); add(ML); add(L);}},\r\n//                new ArrayList<>(){{add(L); add(MH);}},\r\n//                new ArrayList<>(){{add(M); add(H); add(L);}}\r\n//        };\r\n\r\n        return new ArrayList[]{\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);add(PD);add(PE);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);add(PF);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PD);add(PE);add(PF);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PD);add(PE);add(PF);}},\r\n                new ArrayList<>() {{add(PD);add(PE);add(PF);}}\r\n        };\r\n    }\r\n    private static String readTxt(String fileName) throws IOException {\r\n        File file = new File(fileName);\r\n        FileReader fr = new FileReader(file);\r\n        BufferedReader br = new BufferedReader(fr);\r\n        String line;\r\n        String txt = \"\";\r\n        while((line = br.readLine()) != null){\r\n            if(line.length() > 5){\r\n                txt += \"\\n\" + line;\r\n            }\r\n        }\r\n        return txt;\r\n    }\r\n\r\n    private static int getLines(String fileName) throws IOException {\r\n        File file = new File(fileName);\r\n        FileReader fr = new FileReader(file);\r\n        BufferedReader br = new BufferedReader(fr);\r\n        int counter = 0;\r\n        String line;\r\n        while((line = br.readLine()) != null){\r\n            if(line.length() > 5){\r\n                counter++;\r\n            }\r\n        }\r\n        return counter;\r\n    }\r\n    private static void writeTxt(String fileName, String newText) throws IOException {\r\n        File myObj = new File(fileName);\r\n        if (myObj.createNewFile()) {\r\n            System.out.println(\"File created: \" + myObj.getName());\r\n        }\r\n        String fileData = readTxt(fileName);\r\n        fileData = newText  + fileData;\r\n        FileOutputStream fos = new FileOutputStream(fileName);\r\n        fos.write(fileData.getBytes());\r\n        fos.flush();\r\n        fos.close();\r\n    }\r\n\r\n    public static void rechne(int numberOfDecisionMaker, int alt, int crit, Class jugClazz, Class prefClazz) throws IOException {\r\n        String berechnungsName;\r\n\r\n        if(jugClazz == LexJudgements.class){\r\n            berechnungsName = \"Lex \" + numberOfDecisionMaker + \" x \" + alt + \" x \" + crit;\r\n        }else {\r\n            berechnungsName = \"FuzzySAW \" + numberOfDecisionMaker + \" x \" + alt + \" x \" + crit;\r\n        }\r\n        String fileName = System.getProperty(\"user.dir\") + \"\\\\src\\\\main\\\\resources\\\\Berechnungen\\\\\" + berechnungsName + \".txt\";\r\n        Date startDate = new Date();\r\n        Date endDate = new Date();\r\n        System.out.println(\"Start: \" + startDate);\r\n        double sum = 0;\r\n        int durchlaeufe = 100;\r\n        int probleme = 1000;\r\n        double overAllSum = 0;\r\n\r\n\r\n        for (int l = 0; l < probleme; l++) {\r\n            ArrayList<Object[][]> decisionMakerList = MonteCarloHelper.generateDecisionMakerList(jugClazz, numberOfDecisionMaker, alt, crit, 1, 10);\r\n            ArrayList<Object[]> decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(prefClazz, numberOfDecisionMaker, crit, 0, 1);\r\n            ArrayList<Object>[][] aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n            ArrayList<Object>[] aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            //aggregatedMatrix = getMatrix();\r\n            //aggregatedWeights = getWeights();\r\n            int indivCounter = 0;\r\n            for (int k = 0; k < durchlaeufe; k++) {\r\n                List<Map<String, Object>> lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, show);\r\n                indivCounter++;\r\n                while (!containsZero(lowestValue)) {\r\n                    getRandomPath(aggregatedMatrix, aggregatedWeights, lowestValue);\r\n                    lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, show);\r\n                    indivCounter++;\r\n                }\r\n//                System.out.println(\"Pfadlänge: \" + indivCounter);\r\n                sum += indivCounter;\r\n                indivCounter = 0;\r\n                aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n                aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n//                aggregatedMatrix = getMatrix();\r\n//                aggregatedWeights = getWeights();\r\n            }\r\n            decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(FuzzyPreferenzes.class, numberOfDecisionMaker, alt, 0, 1);\r\n            decisionMakerList = MonteCarloHelper.generateDecisionMakerList(FuzzyJudgements.class, numberOfDecisionMaker, alt, crit, 1, 10);\r\n            aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n            aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            endDate = new Date();\r\n            writeTxt(fileName, l + \" Durchschnittliche Pfadlänge = \" + sum / durchlaeufe + \" : \" + endDate);\r\n            System.out.println(l + \" Durchschnittliche Pfadlänge = \" + sum / durchlaeufe + \" : \" + endDate);\r\n            if(sum / durchlaeufe == 1000){\r\n                Helper.show2DArray(aggregatedMatrix);\r\n                Helper.show1DArray(aggregatedWeights);\r\n            }\r\n            overAllSum += sum;\r\n            sum = 0;\r\n        }\r\n        writeTxt(fileName, probleme+ \" Durchschnittliche Pfadlänge = \" + overAllSum / (durchlaeufe*probleme) + \" : \" + endDate);\r\n        System.out.println(probleme+ \" Durchschnittliche Pfadlänge = \" + overAllSum / (durchlaeufe*probleme) + \" : \" + endDate);\r\n        System.out.println(\"End: \" + endDate);\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        int[] numberOfDecisionMakers = {3,4,5,6};\r\n        int[] alt = {3,4,5,6,7,8,9,10};\r\n        int[] crit = {3,4,5,6};\r\n        Class[] jugdClazz = {LexJudgements.class, FuzzyJudgements.class};\r\n        Class[] prefClazz = {LexPreferenzes.class, FuzzyPreferenzes.class};\r\n\r\n        for(int i = 0; i < numberOfDecisionMakers.length; i++){\r\n            for (int j = 0; j < alt.length; j++){\r\n                for(int k = 0; k < crit.length; k++){\r\n                    for(int l = 0; l < jugdClazz.length; l++){\r\n                        rechne(numberOfDecisionMakers[i], alt[j], crit[k], jugdClazz[l], prefClazz[l]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n        19.10 13 Uhr\r\n\r\n        - adm und its\r\n        - nicht quadratisches problem testen\r\n        - berechnungszeit checken\r\n            + probleme generieren, aggregierte generieren\r\n            + berechnungsmethode(lex, saw)\r\n            + kombinationen\r\n            + statistik Matrizen\r\n        Berechnung:\r\n            - 1 Pfad mit idealauflösung 3,5,5, 7 klassen, 1000 Probleme\r\n            - 100 Pfade mit zufallsauflösung\r\n            - wenn k unter 1000 soll voll gerechnet werden\r\n            - 1000 Probleme\r\n            - Anzahl der DM:    3,4,5,6\r\n            - Anzahl der Crit:  3,4,5,6,7,8,9,10\r\n            - Anzahl der Alt:   3,4,5,6\r\n        - zufällige pfade wählen\r\n        - Fuzzy 5 lex 5 als Standard\r\n        - danach fuzzy 3 lex 3\r\n        - danach fuzzy 7 lex 7\r\n        - nicht nur die niedrigsten Werte der entropie ausgeben lassen sondern die niedrigsten 3-5\r\n        Teststudie 24.10.\r\n        - gedanken zum ersten intro machen und durchführen\r\n        - flyer oder link für aktivitäten heraussuchen damit bewertet werden kann\r\n        - mit vorgesetzten sprechen für zeitlichen ablauf\r\n         */\r\n\r\n\r\n        /*\r\n        - überprüfe automatisch bis wo bereits gerechnet wurde und setze es fort\r\n        - Montecarlo 10.000?\r\n        - Ab wie vielen Kombinationsmöglichgkeiten kann random die matrix erstellt werden?\r\n        + speicher von zwischenständen in file\r\n        + einlesen von abgespeicherten daten\r\n        + erste berechnungen\r\n        + bug bei nicht quadratischen problemen\r\n        - zählen bei optimierter variante\r\n        + neue zufallsbildung von instanzen da out of memory\r\n        - dauerschleifen durch reset beenden? reicht while lowest entropy < 0.1?\r\n            - abbruch : wenn bei rankac bei rang 1 mehrfach 1 vorkommt\r\n        + Termin Sonntag 26.11. -> 19.11.\r\n         */\r\n    }\r\n\r\n    public static boolean containsZero(List<Map<String, Object>> lowestValue){\r\n        for(Map map : lowestValue){\r\n            if((Double) map.get(\"lowestValue\") == 0){\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static void getIdealPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, Map<String, Object> lowestValue) {\r\n        if ((Boolean) lowestValue.get(\"lowestValueIsJudgement\")) {\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")] = new ArrayList<>();\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].add(lowestValue.get(\"lowestKey\"));\r\n        } else {\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")] = new ArrayList<>();\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].add(lowestValue.get(\"lowestKey\"));\r\n        }\r\n    }\r\n\r\n    public static void getRandomPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, List<Map<String, Object>>  lowestValue) {\r\n        Random random = new Random();\r\n        for(Map<String, Object> map : lowestValue){\r\n            if ((Boolean) map.get(\"lowestValueIsJudgement\")) {\r\n                if(aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].size() > 1){\r\n                    Integer randomNumber = random.nextInt(aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].size());\r\n                    Object randomObject = aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].get(randomNumber);\r\n                    aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")] = new ArrayList<>();\r\n                    aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].add(randomObject);\r\n                    break;\r\n                }\r\n\r\n            } else {\r\n                if(aggregatedWeights[(Integer) map.get(\"lowestI\")].size() > 1){\r\n                    Integer randomNumber = random.nextInt(aggregatedWeights[(Integer) map.get(\"lowestI\")].size());\r\n                    Object randomObject = aggregatedWeights[(Integer) map.get(\"lowestI\")].get(randomNumber);\r\n                    aggregatedWeights[(Integer) map.get(\"lowestI\")] = new ArrayList<>();\r\n                    aggregatedWeights[(Integer) map.get(\"lowestI\")].add(randomObject);\r\n                    break;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Nutzwertanalyse.java b/src/main/java/Nutzwertanalyse.java
--- a/src/main/java/Nutzwertanalyse.java	(revision 0a7d26f76d759c8e28f5ccb9542256576c01866d)
+++ b/src/main/java/Nutzwertanalyse.java	(date 1699369799617)
@@ -10,9 +10,9 @@
 import static Enums.LexJudgements.*;
 
 public class Nutzwertanalyse {
-    public static final int alt = 4;
-    public static final int crit = 5;
-    public static final int numberOfDecisionMaker = 4;
+    public static final int alt = 6;
+    public static final int crit = 6;
+    public static final int numberOfDecisionMaker = 6;
     public static final Class jugClazz = LexJudgements.class;
     public static final Class prefClazz = LexPreferenzes.class;
     public static final boolean full = true;
@@ -326,6 +326,16 @@
             - abbruch : wenn bei rankac bei rang 1 mehrfach 1 vorkommt
         + Termin Sonntag 26.11. -> 19.11.
          */
+
+        /*
+        - Entscheidungsfindung
+        - Bewertungen abgeben
+        - aggregierte variante Basteln
+        - berechnung
+        - Diskussion
+
+
+         */
     }
 
     public static boolean containsZero(List<Map<String, Object>> lowestValue){
