Index: src/main/java/Nutzwertanalyse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.*;\r\n\r\npublic class Nutzwertanalyse {\r\n    public static final int row = 3;\r\n    public static final int col = 3;\r\n    public static final int numberOfDecisionMaker = 3;\r\n    public static final boolean useStaticProblem = false;\r\n    public static final boolean lex = true;\r\n    public static final boolean full = true;\r\n\r\n    public static ArrayList<Object>[][] getMatrix() {\r\n//        return new ArrayList[][]{\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}},\r\n//                        new ArrayList<>(){{add(MG); add(VG);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(VG);}},\r\n//                        new ArrayList<>(){{add(F); add(MG);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MG); add(P); add(VG);}},\r\n//                        new ArrayList<>(){{add(G); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(P);}}\r\n//                }\r\n//        };\r\n\r\n        return new ArrayList[][]{\r\n                {\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(2);}},\r\n                        new ArrayList<>() {{add(0);}}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(0);add(1);add(2);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);add(2);}},\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(1);add(2);}},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);add(2);}},\r\n                        new ArrayList<>() {{ add(0);}},\r\n                        new ArrayList<>() {{ add(2);}},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(1);add(2);}},\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(0);}}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);add(1);}}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(1);}},\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(0);add(1);}},\r\n                        new ArrayList<>() {{add(0);}},\r\n                        new ArrayList<>() {{add(2);add(1);}},\r\n                        new ArrayList<>() {{add(1);}}\r\n                }\r\n        };\r\n    }\r\n\r\n    public static ArrayList<Object>[] getWeights() {\r\n//        return new ArrayList[]{\r\n//                new ArrayList<>(){{add(H); add(ML); add(L);}},\r\n//                new ArrayList<>(){{add(L); add(MH);}},\r\n//                new ArrayList<>(){{add(M); add(H); add(L);}}\r\n//        };\r\n\r\n        return new ArrayList[]{\r\n                new ArrayList<>() {{add(0);add(1);add(2);add(3);add(4);}},\r\n                new ArrayList<>() {{add(0);add(1);add(2);}},\r\n                new ArrayList<>() {{add(0);add(1);add(2);add(5);}},\r\n                new ArrayList<>() {{add(0);add(1);add(3);add(4);add(5);}},\r\n                new ArrayList<>() {{add(0);add(1);add(3);add(4);add(5);}},\r\n                new ArrayList<>() {{add(3);add(4);add(5);}}\r\n        };\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        Date startDate = new Date();\r\n        Date endDate = new Date();\r\n        System.out.println(\"Start: \" + startDate);\r\n        for (int l = 0; l < 10; l++) {\r\n            int[][][] aggregatedMatrix = null;\r\n            int[][] aggregatedWeights = null;\r\n            int[][][] decisionMakerList = null;\r\n            int[][] decisionMakerWeightsList = null;\r\n            if(useStaticProblem){\r\n                //gets static problem matrix\r\n                ArrayList<Object>[][] staticAggregatedMatrix = getMatrix();\r\n                ArrayList<Object>[] staticAggregatedWeights = getWeights();\r\n                //transfer static arraylist problem to matrix filled with judgements and -1\r\n                aggregatedMatrix = transferStaticAggregatedMatrixToIntArray(staticAggregatedMatrix);\r\n                aggregatedWeights = transferStaticAggregatedWeightToIntArray(staticAggregatedWeights);\r\n            }else{\r\n                decisionMakerList = MonteCarloHelper.generateDecisionMakerList(numberOfDecisionMaker, row, col, lex);\r\n                decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(numberOfDecisionMaker, row, lex);\r\n                //generates aggregated matrix and fill with -1\r\n                aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n                aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            }\r\n\r\n            int indivCounter = 0;\r\n            double sum = 0;\r\n            int durchlaeufe = 100;\r\n            for (int k = 0; k < durchlaeufe; k++) {\r\n                double[][] lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, lex);\r\n                indivCounter++;\r\n\r\n                while (!containsZero(lowestValue)) {\r\n//                    getRandomPath(aggregatedMatrix, aggregatedWeights, lowestValue);\r\n                    lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, lex);\r\n                    indivCounter++;\r\n                }\r\n                System.out.println(\"Pfadlänge: \" + indivCounter);\r\n                sum += indivCounter;\r\n                indivCounter = 0;\r\n//                aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n//                aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n//                aggregatedMatrix = getMatrix();\r\n//                aggregatedWeights = getWeights();\r\n            }\r\n//            decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(FuzzyPreferenzes.class, numberOfDecisionMaker, row, 0, 1);\r\n//            decisionMakerList = MonteCarloHelper.generateDecisionMakerList(FuzzyJudgements.class, numberOfDecisionMaker, row, col, 1, 10);\r\n            aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n            aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            endDate = new Date();\r\n            System.out.println(l + \" Durchschnittliche Pfadlänge = \" + sum / durchlaeufe + \" : \" + endDate);\r\n            sum = 0;\r\n        }\r\n        System.out.println(\"End: \" + endDate);\r\n        /*\r\n        - adm und its\r\n        - nicht quadratisches problem testen\r\n        -> berechnungszeit checken\r\n        Berechnung:\r\n            - 1 Pfad mit idealauflösung 3,5,5, 7 klassen, 1000 Probleme\r\n            - 100 Pfade mit zufallsauflösung\r\n            - wenn k unter 1000 soll voll gerechnet werden\r\n            - 1000 Probleme\r\n            - Anzahl der DM:    2,3,4,5,6\r\n            - Anzahl der Crit:  3,4,5,6,7,8,9,10\r\n            - Anzahl der Alt:   3,4,5,6\r\n            -\r\n        - zufällige pfade wählen\r\n        - Fuzzy 5 lex 5 als Standard\r\n        - danach fuzzy 3 lex 3\r\n        - danach fuzzy 7 lex 7\r\n        - nicht nur die niedrigsten Werte der entropie ausgeben lassen sondern die niedrigsten 3-5\r\n        Teststudie 24.10.\r\n        gedanken zum ersten intro machen und durchführen\r\n        -> flyer oder link für aktivitäten heraussuchen damit bewertet werden kann\r\n        mit vorgesetzten sprechen für zeitlichen ablauf\r\n         */\r\n    }\r\n\r\n    public static boolean containsZero(double[][] lowestValue){\r\n        for(int i = 0; i < lowestValue.length; i++){\r\n            if(lowestValue[i][0] == 0){\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /*\r\n    nachricht an thony mit den kriterien, alternativen\r\n    nachricht zum erfragen für den 24.10.\r\n\r\n    prüfungsamt schreiben\r\n     */\r\n\r\n\r\n    public static void getIdealPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, Map<String, Object> lowestValue) {\r\n        if ((Boolean) lowestValue.get(\"lowestValueIsJudgement\")) {\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")] = new ArrayList<>();\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].add(lowestValue.get(\"lowestKey\"));\r\n        } else {\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")] = new ArrayList<>();\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].add(lowestValue.get(\"lowestKey\"));\r\n        }\r\n    }\r\n\r\n    public static int[][][] transferStaticAggregatedMatrixToIntArray(ArrayList<Object>[][] staticAggregatedMatrix){\r\n        //fill aggregatedMatrix\r\n        int[][][] aggregatedMatrixArray = new int[staticAggregatedMatrix.length][staticAggregatedMatrix[0].length][];\r\n        for(int i = 0; i < staticAggregatedMatrix.length; i++){\r\n            for(int j = 0; j < staticAggregatedMatrix[i].length; j++){\r\n                int[] var = new int[staticAggregatedMatrix[i][j].size()];\r\n                for(int k = 0; k < staticAggregatedMatrix[i][j].size(); k++){\r\n                    var[k] = (int)staticAggregatedMatrix[i][j].get(k);\r\n                }\r\n                aggregatedMatrixArray[i][j] = var;\r\n            }\r\n        }\r\n        return aggregatedMatrixArray;\r\n    }\r\n\r\n    public static int[][] transferStaticAggregatedWeightToIntArray(ArrayList<Object>[] staticAggregatedWeight){\r\n        int[][] aggregatedWeights = new int[staticAggregatedWeight.length][];\r\n        for(int i = 0; i < staticAggregatedWeight.length; i++){\r\n            int[] var = new int[staticAggregatedWeight[i].size()];\r\n            for(int k = 0; k < staticAggregatedWeight[i].size(); k++){\r\n                var[k] = (int)staticAggregatedWeight[i].get(k);\r\n            }\r\n            aggregatedWeights[i] = var;\r\n        }\r\n        return aggregatedWeights;\r\n    }\r\n\r\n    public static void getRandomPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, Map<String, Object> lowestValue) {\r\n        Random random = new Random();\r\n        if ((Boolean) lowestValue.get(\"lowestValueIsJudgement\")) {\r\n            Integer randomNumber = random.nextInt(aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].size());\r\n            Object randomObject = aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].get(randomNumber);\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")] = new ArrayList<>();\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].add(randomObject);\r\n        } else {\r\n            Integer randomNumber = random.nextInt(aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].size());\r\n            Object randomObject = aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].get(randomNumber);\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")] = new ArrayList<>();\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].add(randomObject);\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Nutzwertanalyse.java b/src/main/java/Nutzwertanalyse.java
--- a/src/main/java/Nutzwertanalyse.java	(revision 9488a028e3895520b5cb323d5f9b65c59d368242)
+++ b/src/main/java/Nutzwertanalyse.java	(date 1700239004691)
@@ -138,8 +138,8 @@
                 indivCounter = 0;
 //                aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);
 //                aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);
-//                aggregatedMatrix = getMatrix();
-//                aggregatedWeights = getWeights();
+                aggregatedMatrix = getMatrix();
+                aggregatedWeights = getWeights();
             }
 //            decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(FuzzyPreferenzes.class, numberOfDecisionMaker, row, 0, 1);
 //            decisionMakerList = MonteCarloHelper.generateDecisionMakerList(FuzzyJudgements.class, numberOfDecisionMaker, row, col, 1, 10);
