Index: src/main/java/Nutzwertanalyse.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import Enums.FuzzyJudgements;\r\nimport Enums.FuzzyPreferenzes;\r\nimport Enums.LexJudgements;\r\nimport Enums.LexPreferenzes;\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\nimport static Enums.LexPreferenzes.*;\r\nimport static Enums.LexJudgements.*;\r\n\r\npublic class Nutzwertanalyse {\r\n    public static final int alt = 5;\r\n    public static final int crit = 5;\r\n    public static final int numberOfDecisionMaker = 5;\r\n    public static final Class jugClazz = LexJudgements.class;\r\n    public static final Class prefClazz = LexPreferenzes.class;\r\n    public static final boolean full = true;\r\n    public static final boolean show = false;\r\n\r\n    public static ArrayList<Object>[][] getMatrix() {\r\n//        return new ArrayList[][]{\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}},\r\n//                        new ArrayList<>(){{add(MG); add(VG);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MP); add(VG);}},\r\n//                        new ArrayList<>(){{add(F); add(MG);}},\r\n//                        new ArrayList<>(){{add(F); add(G);}}\r\n//                },\r\n//                {\r\n//                        new ArrayList<>(){{add(MG); add(P); add(VG);}},\r\n//                        new ArrayList<>(){{add(G); add(P);}},\r\n//                        new ArrayList<>(){{add(F); add(P);}}\r\n//                }\r\n//        };\r\n\r\n        return new ArrayList[][]{\r\n                {\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);}},\r\n                        new ArrayList<>() {{add(JB);}},\r\n                        new ArrayList<>() {{add(JC);}},\r\n                        new ArrayList<>() {{add(JA);}}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(JA);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);add(JC);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);}},\r\n                        new ArrayList<>() {{add(JA);add(JB);add(JC);}},\r\n                        new ArrayList<>() {{add(JB);}},\r\n                        new ArrayList<>() {{add(JB);add(JC);}},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                            add(JC);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JC);\r\n                        }},\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                            add(JC);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }}\r\n                },\r\n                {\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JA);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JC);\r\n                            add(JB);\r\n                        }},\r\n                        new ArrayList<>() {{\r\n                            add(JB);\r\n                        }}\r\n                }\r\n        };\r\n    }\r\n\r\n    public static ArrayList<Object>[] getWeights() {\r\n//        return new ArrayList[]{\r\n//                new ArrayList<>(){{add(H); add(ML); add(L);}},\r\n//                new ArrayList<>(){{add(L); add(MH);}},\r\n//                new ArrayList<>(){{add(M); add(H); add(L);}}\r\n//        };\r\n\r\n        return new ArrayList[]{\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);add(PD);add(PE);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PC);add(PF);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PD);add(PE);add(PF);}},\r\n                new ArrayList<>() {{add(PA);add(PB);add(PD);add(PE);add(PF);}},\r\n                new ArrayList<>() {{add(PD);add(PE);add(PF);}}\r\n        };\r\n    }\r\n    private static String readTxt(String fileName) throws IOException {\r\n        File file = new File(fileName);\r\n        FileReader fr = new FileReader(file);\r\n        BufferedReader br = new BufferedReader(fr);\r\n        String line;\r\n        String txt = \"\";\r\n        while((line = br.readLine()) != null){\r\n            if(line.length() > 5){\r\n                txt += \"\\n\" + line;\r\n            }\r\n        }\r\n        return txt;\r\n    }\r\n\r\n    private static int getLines(String fileName) throws IOException {\r\n        File file = new File(fileName);\r\n        FileReader fr = new FileReader(file);\r\n        BufferedReader br = new BufferedReader(fr);\r\n        int counter = 0;\r\n        String line;\r\n        while((line = br.readLine()) != null){\r\n            if(line.length() > 5){\r\n                counter++;\r\n            }\r\n        }\r\n        return counter;\r\n    }\r\n\r\n    private static boolean fileExist(String fileName) throws IOException {\r\n        File file = new File(fileName);\r\n        if (file.createNewFile()) {\r\n            System.out.println(\"File created: \" + file.getName());\r\n            return false;\r\n        }else {\r\n            System.out.println(\"File already exists: \" + fileName.substring(fileName.lastIndexOf(\"\\\\\")));\r\n            return true;\r\n        }\r\n    }\r\n    private static void writeTxt(String fileName, String newText) throws IOException {\r\n        File myObj = new File(fileName);\r\n        if (myObj.createNewFile()) {\r\n            System.out.println(\"File created: \" + myObj.getName());\r\n        }\r\n        String fileData = readTxt(fileName);\r\n        fileData = newText  + fileData;\r\n        FileOutputStream fos = new FileOutputStream(fileName);\r\n        fos.write(fileData.getBytes());\r\n        fos.flush();\r\n        fos.close();\r\n    }\r\n\r\n    public static void rechne(int numberOfDecisionMaker, int alt, int crit, Class jugClazz, Class prefClazz) throws IOException {\r\n        String berechnungsName;\r\n\r\n        if(jugClazz == LexJudgements.class){\r\n            berechnungsName = \"Lex \" + numberOfDecisionMaker + \" x \" + alt + \" x \" + crit;\r\n        }else {\r\n            berechnungsName = \"FuzzySAW \" + numberOfDecisionMaker + \" x \" + alt + \" x \" + crit;\r\n        }\r\n        String fileName = System.getProperty(\"user.dir\") + \"\\\\src\\\\main\\\\resources\\\\Berechnungen\\\\\" + berechnungsName + \".txt\";\r\n        fileExist(fileName);\r\n\r\n        Date startDate = new Date();\r\n        Date endDate = new Date();\r\n        System.out.println(\"Start: \" + startDate);\r\n        double sum = 0;\r\n        int durchlaeufe = 100;\r\n        int probleme = 1000;\r\n        double overAllSum = 0;\r\n        int linesInFile = getLines(fileName);\r\n\r\n        for (int l = linesInFile; l < probleme; l++) {\r\n            ArrayList<Object[][]> decisionMakerList = MonteCarloHelper.generateDecisionMakerList(jugClazz, numberOfDecisionMaker, alt, crit, 1, 10);\r\n            ArrayList<Object[]> decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(prefClazz, numberOfDecisionMaker, crit, 0, 1);\r\n            ArrayList<Object>[][] aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n            ArrayList<Object>[] aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            //aggregatedMatrix = getMatrix();\r\n            //aggregatedWeights = getWeights();\r\n            int indivCounter = 0;\r\n            List<Map<String, Object>> lowestValue = null;\r\n            for (int k = 0; k < durchlaeufe; k++) {\r\n                lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, show);\r\n                indivCounter++;\r\n                while (!containsZero(lowestValue)) {\r\n                    getRandomPath(aggregatedMatrix, aggregatedWeights, lowestValue);\r\n                    lowestValue = MonteCarloHelper.showMonteCarloSaw(aggregatedMatrix, aggregatedWeights, full, show);\r\n                    if(lowestValue == null){\r\n                        break;\r\n                    }\r\n                    indivCounter++;\r\n                }\r\n//                System.out.println(\"Pfadlänge: \" + indivCounter);\r\n                if(lowestValue == null){\r\n                    break;\r\n                }\r\n                sum += indivCounter;\r\n                indivCounter = 0;\r\n                aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n                aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n//                aggregatedMatrix = getMatrix();\r\n//                aggregatedWeights = getWeights();\r\n            }\r\n            if (lowestValue == null){\r\n                l--;\r\n                continue;\r\n            }\r\n            decisionMakerWeightsList = MonteCarloHelper.generateDecisionMakerWeightList(FuzzyPreferenzes.class, numberOfDecisionMaker, alt, 0, 1);\r\n            decisionMakerList = MonteCarloHelper.generateDecisionMakerList(FuzzyJudgements.class, numberOfDecisionMaker, alt, crit, 1, 10);\r\n            aggregatedMatrix = MonteCarloHelper.generateAggregatedMatrix(decisionMakerList);\r\n            aggregatedWeights = MonteCarloHelper.generateAggregatedWeights(decisionMakerWeightsList);\r\n            endDate = new Date();\r\n            writeTxt(fileName, l + \" Durchschnittliche Pfadlänge = \" + sum / durchlaeufe + \" : \" + endDate);\r\n            System.out.println(l + \" Durchschnittliche Pfadlänge = \" + sum / durchlaeufe + \" : \" + endDate);\r\n            if(sum / durchlaeufe == 1000){\r\n                Helper.show2DArray(aggregatedMatrix);\r\n                Helper.show1DArray(aggregatedWeights);\r\n            }\r\n            overAllSum += sum;\r\n            sum = 0;\r\n        }\r\n        System.out.println(berechnungsName + \" done.\");\r\n        System.out.println(\"End: \" + endDate);\r\n    }\r\n\r\n    public static void main(String[] args) throws IOException {\r\n        int[] numberOfDecisionMakers = {3,4,5,6};\r\n        int[] alt = {3,4,5,6,7,8,9,10};\r\n        int[] crit = {3,4,5,6};\r\n        Class[] jugdClazz = {LexJudgements.class};\r\n        Class[] prefClazz = {LexPreferenzes.class};\r\n\r\n        for(int i = 0; i < numberOfDecisionMakers.length; i++){\r\n            for (int j = 0; j < alt.length; j++){\r\n                for(int k = 0; k < crit.length; k++){\r\n                    for(int l = 0; l < jugdClazz.length; l++){\r\n                        rechne(numberOfDecisionMakers[i], alt[j], crit[k], jugdClazz[l], prefClazz[l]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n        19.10 13 Uhr\r\n\r\n        - adm und its\r\n        - nicht quadratisches problem testen\r\n        - berechnungszeit checken\r\n            + probleme generieren, aggregierte generieren\r\n            + berechnungsmethode(lex, saw)\r\n            + kombinationen\r\n            + statistik Matrizen\r\n        Berechnung:\r\n            - 1 Pfad mit idealauflösung 3,5,5, 7 klassen, 1000 Probleme\r\n            - 100 Pfade mit zufallsauflösung\r\n            - wenn k unter 1000 soll voll gerechnet werden\r\n            - 1000 Probleme\r\n            - Anzahl der DM:    3,4,5,6\r\n            - Anzahl der Crit:  3,4,5,6,7,8,9,10\r\n            - Anzahl der Alt:   3,4,5,6\r\n        - zufällige pfade wählen\r\n        - Fuzzy 5 lex 5 als Standard\r\n        - danach fuzzy 3 lex 3\r\n        - danach fuzzy 7 lex 7\r\n        - nicht nur die niedrigsten Werte der entropie ausgeben lassen sondern die niedrigsten 3-5\r\n        Teststudie 24.10.\r\n        - gedanken zum ersten intro machen und durchführen\r\n        - flyer oder link für aktivitäten heraussuchen damit bewertet werden kann\r\n        - mit vorgesetzten sprechen für zeitlichen ablauf\r\n         */\r\n\r\n\r\n        /*\r\n        - überprüfe automatisch bis wo bereits gerechnet wurde und setze es fort\r\n        - Montecarlo 10.000?\r\n        - Ab wie vielen Kombinationsmöglichgkeiten kann random die matrix erstellt werden?\r\n        + speicher von zwischenständen in file\r\n        + einlesen von abgespeicherten daten\r\n        + erste berechnungen\r\n        + bug bei nicht quadratischen problemen\r\n        - zählen bei optimierter variante\r\n        + neue zufallsbildung von instanzen da out of memory\r\n        - dauerschleifen durch reset beenden? reicht while lowest entropy < 0.1?\r\n            - abbruch : wenn bei rankac bei rang 1 mehrfach 1 vorkommt\r\n        + Termin Sonntag 26.11. -> 19.11.\r\n         */\r\n    }\r\n\r\n    public static boolean containsZero(List<Map<String, Object>> lowestValue){\r\n        for(Map map : lowestValue){\r\n            if((Double) map.get(\"lowestValue\") == 0){\r\n               return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static void getIdealPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, Map<String, Object> lowestValue) {\r\n        if ((Boolean) lowestValue.get(\"lowestValueIsJudgement\")) {\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")] = new ArrayList<>();\r\n            aggregatedMatrix[(Integer) lowestValue.get(\"lowestI\")][(Integer) lowestValue.get(\"lowestJ\")].add(lowestValue.get(\"lowestKey\"));\r\n        } else {\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")] = new ArrayList<>();\r\n            aggregatedWeights[(Integer) lowestValue.get(\"lowestI\")].add(lowestValue.get(\"lowestKey\"));\r\n        }\r\n    }\r\n\r\n    public static void getRandomPath(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, List<Map<String, Object>>  lowestValue) {\r\n        Random random = new Random();\r\n        for(Map<String, Object> map : lowestValue){\r\n            if ((Boolean) map.get(\"lowestValueIsJudgement\")) {\r\n                if(aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].size() > 1){\r\n                    Integer randomNumber = random.nextInt(aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].size());\r\n                    Object randomObject = aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].get(randomNumber);\r\n                    aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")] = new ArrayList<>();\r\n                    aggregatedMatrix[(Integer) map.get(\"lowestI\")][(Integer) map.get(\"lowestJ\")].add(randomObject);\r\n                    break;\r\n                }\r\n\r\n            } else {\r\n                if(aggregatedWeights[(Integer) map.get(\"lowestI\")].size() > 1){\r\n                    Integer randomNumber = random.nextInt(aggregatedWeights[(Integer) map.get(\"lowestI\")].size());\r\n                    Object randomObject = aggregatedWeights[(Integer) map.get(\"lowestI\")].get(randomNumber);\r\n                    aggregatedWeights[(Integer) map.get(\"lowestI\")] = new ArrayList<>();\r\n                    aggregatedWeights[(Integer) map.get(\"lowestI\")].add(randomObject);\r\n                    break;\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/Nutzwertanalyse.java b/src/main/java/Nutzwertanalyse.java
--- a/src/main/java/Nutzwertanalyse.java	(revision 2b64650cc2621ad314cb439371d936cc2b1ac45c)
+++ b/src/main/java/Nutzwertanalyse.java	(date 1699393062048)
@@ -292,9 +292,9 @@
         int[] numberOfDecisionMakers = {3,4,5,6};
         int[] alt = {3,4,5,6,7,8,9,10};
         int[] crit = {3,4,5,6};
-        Class[] jugdClazz = {LexJudgements.class};
-        Class[] prefClazz = {LexPreferenzes.class};
-
+        Class[] jugdClazz = {FuzzyJudgements.class};
+        Class[] prefClazz = {FuzzyPreferenzes.class};
+        rechne(6, 10, 6, jugdClazz[0], prefClazz[0]);
         for(int i = 0; i < numberOfDecisionMakers.length; i++){
             for (int j = 0; j < alt.length; j++){
                 for(int k = 0; k < crit.length; k++){
@@ -338,7 +338,7 @@
         /*
         - überprüfe automatisch bis wo bereits gerechnet wurde und setze es fort
         - Montecarlo 10.000?
-        - Ab wie vielen Kombinationsmöglichgkeiten kann random die matrix erstellt werden?
+        - Ab wie vielen Kombinationsmöglichgkeiten kann die matrix random erstellt werden?
         + speicher von zwischenständen in file
         + einlesen von abgespeicherten daten
         + erste berechnungen
Index: src/main/java/MonteCarloHelper.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import Enums.LexPreferenzes;\r\nimport org.jetbrains.annotations.NotNull;\r\n\r\nimport java.util.*;\r\n\r\npublic class MonteCarloHelper {\r\n    public static int monteCarloIterations = 1000;\r\n    public static int iteration;\r\n    public static int alt;\r\n    public static int crit;\r\n    public static int k;\r\n    public static long size = 0;\r\n    public static boolean individual = false;\r\n\r\n    public static void main(String[] args) {\r\n        Map<Integer, Integer> list = new HashMap<>();\r\n        for(int i = 0; i < 100; i++){\r\n            list.put(i, 0);\r\n        }\r\n        Random random = new Random();\r\n        int number = 0;\r\n        Integer sum;\r\n        int totals = 1000000;\r\n        for(int i = 0; i < totals; i++){\r\n            number = random.nextInt(100);\r\n            sum = list.get(number);\r\n            list.put(number, sum + 1);\r\n        }\r\n\r\n        for(int i = 0; i < 100; i++){\r\n            System.out.println(list.get(i));\r\n        }\r\n        System.out.println(list);\r\n    }\r\n\r\n    public static List<Map<String, Object>>  showMonteCarloSaw(ArrayList<Object>[][] aggregatedMatrix, ArrayList<Object>[] aggregatedWeights, boolean full, boolean show){\r\n        alt = aggregatedMatrix.length;\r\n        crit = aggregatedWeights.length;\r\n\r\n        List<List<Object>> preferenceCombinationList = getPreferenceCombinations(aggregatedWeights);\r\n        List<List<Object>> judgementCombinationList = getJudgementCombinations(aggregatedMatrix);\r\n\r\n        if(judgementCombinationList == null){\r\n            //use individual instance generation\r\n            k = 1_000_000_000;\r\n            individual = true;\r\n        }else{\r\n            k = judgementCombinationList.size() * preferenceCombinationList.size();\r\n        }\r\n\r\n        Object[][] sawMatrix = null;\r\n        Object[] sawWeights = null;\r\n        Object[] rankingTotalPoints;\r\n        Object[] rankingPosition;\r\n        Object[][] rankAcceptabilityIndices = new Object[alt][alt];\r\n        //fill ranking counter with 0\r\n        for(int i = 0; i < alt; i++){\r\n            for(int j = 0; j < alt; j++){\r\n                rankAcceptabilityIndices[i][j] = 0.0;\r\n            }\r\n        }\r\n\r\n        // generate map for counting\r\n        Map<Object, Object>[][] currentJudgementAcceptabilityIndices = new Map[alt][crit];\r\n        Map<Object, Object>[][] potentialJudgementAcceptabilityIndices = new Map[alt][crit];\r\n        Map<Object, Object>[] currentPreferenceAcceptabilityIndices = new Map[crit];\r\n        Map<Object, Object>[] potentialPreferencesAcceptabilityIndices = new Map[crit];\r\n\r\n        //fill matrix map with 0\r\n        fillMatrixMapWithZero(aggregatedMatrix, currentJudgementAcceptabilityIndices);\r\n        fillMatrixMapWithZero(aggregatedMatrix, potentialJudgementAcceptabilityIndices);\r\n        //fill weights map with 0\r\n        fillWeightsMapWithZero(aggregatedWeights, currentPreferenceAcceptabilityIndices);\r\n        fillWeightsMapWithZero(aggregatedWeights, potentialPreferencesAcceptabilityIndices);\r\n\r\n        //create currentJudgementAcceptabilityIndices and currentPreferenceAcceptabilityIndices\r\n        //create potentialJudgementAcceptabilityIndices and potentialPreferenceAcceptabilityIndices\r\n        ArrayList<Map<Object, Object>[][]> objectCurrentJudgementAcceptabilityIndices = new ArrayList<>();\r\n        //[index for ai is winning][row][col][map for possible decisions]\r\n        ArrayList<Map<Object, Object>[][]> objectPotentialJudgementAcceptabilityIndices = new ArrayList<>();\r\n        for(int j = 0; j < alt; j++){\r\n            objectCurrentJudgementAcceptabilityIndices.add(currentJudgementAcceptabilityIndices);\r\n            currentJudgementAcceptabilityIndices = new Map[alt][crit];\r\n            fillMatrixMapWithZero(aggregatedMatrix, currentJudgementAcceptabilityIndices);\r\n\r\n            objectPotentialJudgementAcceptabilityIndices.add(potentialJudgementAcceptabilityIndices);\r\n            potentialJudgementAcceptabilityIndices = new Map[alt][crit];\r\n            fillMatrixMapWithZero(aggregatedMatrix, potentialJudgementAcceptabilityIndices);\r\n        }\r\n\r\n        ArrayList<Map<Object, Object>[]> objectCurrentPreferenceAcceptabilityIndices = new ArrayList<>();\r\n        ArrayList<Map<Object, Object>[]> objectPotentialPreferenceAcceptabilityIndices = new ArrayList<>();\r\n        for(int j = 0; j < alt; j++){\r\n            objectCurrentPreferenceAcceptabilityIndices.add(currentPreferenceAcceptabilityIndices);\r\n            currentPreferenceAcceptabilityIndices = new Map[crit];\r\n            fillWeightsMapWithZero(aggregatedWeights, currentPreferenceAcceptabilityIndices);\r\n\r\n            objectPotentialPreferenceAcceptabilityIndices.add(potentialPreferencesAcceptabilityIndices);\r\n            potentialPreferencesAcceptabilityIndices = new Map[crit];\r\n            fillWeightsMapWithZero(aggregatedWeights, potentialPreferencesAcceptabilityIndices);\r\n        }\r\n\r\n        //monteCarloSimulation\r\n        if(k < 1000){\r\n            full = true;\r\n            iteration = k;\r\n        }else{\r\n            full = false;\r\n            iteration = monteCarloIterations;\r\n        }\r\n        int prefCounter = 0;\r\n        int jugCounter = 0;\r\n        for(int i = 0; i < iteration - 1; i++){\r\n            if(full){\r\n                if(jugCounter == judgementCombinationList.size()){\r\n                    jugCounter = 0;\r\n                    prefCounter++;\r\n\r\n                }\r\n                sawMatrix = listToMatrix(judgementCombinationList.get(jugCounter), alt);\r\n\r\n                jugCounter++;\r\n                sawWeights = preferenceCombinationList.get(prefCounter).toArray();\r\n\r\n            }else{\r\n                Random random = new Random();\r\n                int rngNumberW = -1;\r\n                try{\r\n                    rngNumberW = random.nextInt(preferenceCombinationList.size());\r\n                }catch (Exception e){\r\n                    return null;\r\n                }\r\n\r\n                sawWeights = preferenceCombinationList.get(rngNumberW).toArray();\r\n                if(individual){\r\n                    sawMatrix = generateIndividualMatrix(aggregatedMatrix);\r\n                }else{\r\n                    int rngNumberM = random.nextInt(judgementCombinationList.size());\r\n                    sawMatrix = listToMatrix(judgementCombinationList.get(rngNumberM), alt);\r\n                }\r\n            }\r\n\r\n            if(i > 38928000){\r\n                rankingTotalPoints = Helper.saw(sawMatrix, sawWeights, false);\r\n            }else {\r\n                rankingTotalPoints = Helper.saw(sawMatrix, sawWeights, false);\r\n            }\r\n\r\n\r\n            rankingPosition = getRanksArray(rankingTotalPoints);\r\n            addRanking(rankAcceptabilityIndices, rankingPosition);\r\n            if(show){\r\n                System.out.println(\"\\n ranking \");\r\n                Helper.show1DArray(rankingPosition);\r\n                System.out.println(\"\\n rankAcceptabilityIndices \");\r\n                Helper.showAcceptabilityIndices(rankAcceptabilityIndices);\r\n            }\r\n            //sawMatrix + ranking = countingMatrixRankingMap\r\n            countByRankingAndDecision(rankingPosition, objectCurrentJudgementAcceptabilityIndices, sawMatrix);\r\n            //sawWeights + ranking = countingWeightsRankingMap\r\n            countByRankingAndWeights(rankingPosition, objectCurrentPreferenceAcceptabilityIndices, sawWeights);\r\n\r\n            if(false){\r\n                System.out.println(\"\\nMatrix\");\r\n                Helper.show2DArray(sawMatrix);\r\n                System.out.println(\"\\nWeight\");\r\n                Helper.show1DArray(sawWeights);\r\n                System.out.println(\"\\n rankingTotalPoints\");\r\n                Helper.show1DArray(rankingTotalPoints);\r\n                System.out.println(\"\\n rankingPosition\");\r\n                Helper.show1DArray(rankingPosition);\r\n                System.out.println(\"\\n new rankAcceptabilityIndices\");\r\n                Helper.show2DArray(rankAcceptabilityIndices);\r\n                System.out.println(\"\\n new objectCurrentJudgementAcceptabilityIndices\");\r\n                Helper.show2DArray(objectCurrentJudgementAcceptabilityIndices.get(0));\r\n            }\r\n\r\n        }\r\n\r\n        if(show){\r\n            System.out.println(\"\\nAggregated Matrix\");\r\n            Helper.show2DArray(aggregatedMatrix);\r\n\r\n            System.out.println(\"\\nAggregated Weight\");\r\n            Helper.show1DArray(aggregatedWeights);\r\n\r\n            System.out.println(\"\\nAggregated K: \" + k);\r\n            System.out.println(\"\\nfinal rankAcceptabilityIndices \");\r\n            Helper.showAcceptabilityIndices(rankAcceptabilityIndices);\r\n        }\r\n\r\n        normalizeTotalRankingPositions(rankAcceptabilityIndices);\r\n        if(show){\r\n            System.out.println(\"\\nfinal rankAcceptabilityIndices scaled\");\r\n            Helper.showAcceptabilityIndices(rankAcceptabilityIndices);\r\n        }\r\n\r\n        scaleAggregatedMatrixMap(objectCurrentJudgementAcceptabilityIndices);\r\n        if(show){\r\n            for(int j = 0; j < alt; j++){\r\n                System.out.println(\"\\ncurrentJudgementAcceptabilityIndex for a\" + j);\r\n                Helper.show2DArray(objectCurrentJudgementAcceptabilityIndices.get(j));\r\n            }\r\n        }\r\n\r\n        scaleAggregatedWeightsMap(objectCurrentPreferenceAcceptabilityIndices);\r\n        if(show){\r\n            for (int i = 0; i < crit; i++){\r\n                System.out.println(\"\\ncurrentPreferenceAcceptabilityIndex for a\" + i);\r\n                Helper.show1DArray(objectCurrentPreferenceAcceptabilityIndices.get(i));\r\n            }\r\n        }\r\n\r\n        fillPotentialJudgementAcceptabilityIndices(objectCurrentJudgementAcceptabilityIndices, objectPotentialJudgementAcceptabilityIndices);\r\n        if(show){\r\n            for(int j = 0; j < alt; j++){\r\n                System.out.println(\"\\npotentialJudgementAcceptabilityIndex for a\" + j);\r\n                Helper.show2DArray(objectPotentialJudgementAcceptabilityIndices.get(j));\r\n            }\r\n        }\r\n\r\n        fillPotentialAggregatedWeightsRankingMap(objectCurrentPreferenceAcceptabilityIndices, objectPotentialPreferenceAcceptabilityIndices);\r\n        if(show){\r\n            for (int i = 0; i < crit; i++){\r\n                System.out.println(\"\\npotentialPreferenceAcceptabilityIndex for a\" + i);\r\n                Helper.show1DArray(objectPotentialPreferenceAcceptabilityIndices.get(i));\r\n            }\r\n        }\r\n\r\n        Map<Object, Double>[][] judgementEntropyMatrix = getEntropyMatrix(objectPotentialJudgementAcceptabilityIndices);\r\n        Map<Object, Double>[] preferenceEntropy = getEntropyPreference(objectPotentialPreferenceAcceptabilityIndices);\r\n\r\n        if(show){\r\n            System.out.println(\"\\njudgementEntropyMatrix\");\r\n            Helper.show2DArray(judgementEntropyMatrix);\r\n            System.out.println(\"\\npreferenceEntropy\");\r\n            Helper.show1DArray(preferenceEntropy);\r\n            System.out.println(\"\\ncurrent entropy\");\r\n            System.out.println(getCurrentEntropy(rankAcceptabilityIndices));\r\n        }\r\n        return getLowestValue(judgementEntropyMatrix, preferenceEntropy);\r\n    }\r\n\r\n    public static Object[][] generateIndividualMatrix(ArrayList<Object>[][] aggregatedMatrix){\r\n        Object[][] generatedMatrix = new Object[aggregatedMatrix.length][aggregatedMatrix[0].length];\r\n        Random random = new Random();\r\n        int rngNumber;\r\n        for(int i = 0; i < aggregatedMatrix.length; i++){\r\n            for(int j = 0; j < aggregatedMatrix[i].length; j++){\r\n                 rngNumber = random.nextInt(aggregatedMatrix[i][j].size());\r\n                generatedMatrix[i][j] = aggregatedMatrix[i][j].get(rngNumber);\r\n            }\r\n        }\r\n        return generatedMatrix;\r\n    }\r\n    public static boolean doubleOne(Object[] ranking){\r\n        int counter = 0;\r\n        for(int i = 0; i < ranking.length; i++){\r\n            if((Integer)ranking[i] == 1){\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        if(counter == 2){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static List<Map<String, Object>> getLowestValue(Map<Object, Double>[][] judgementEntropyMatrix, Map<Object, Double>[] preferenceEntropy){\r\n        List  list = new ArrayList<>();\r\n        List<Map<String, Object>> lowestValues = new ArrayList<>();\r\n        Map<String, Object> map = new HashMap<>();\r\n        //add all values to list\r\n        for (int i = 0; i < judgementEntropyMatrix.length; i++) {\r\n            for(int j = 0; j < judgementEntropyMatrix[i].length; j++){\r\n                for (Object key: judgementEntropyMatrix[i][j].keySet()) {\r\n                    list.add(judgementEntropyMatrix[i][j].get(key));\r\n                }\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < preferenceEntropy.length; i++){\r\n            for (Object key: preferenceEntropy[i].keySet()) {\r\n                list.add(preferenceEntropy[i].get(key));\r\n            }\r\n        }\r\n        //sort\r\n        Collections.sort(list);\r\n        //search vor lowest values\r\n        for (int i = 0; i < judgementEntropyMatrix.length; i++) {\r\n            for(int j = 0; j < judgementEntropyMatrix[i].length; j++){\r\n                for (Object key: judgementEntropyMatrix[i][j].keySet()) {\r\n                    map.put(\"lowestValue\", judgementEntropyMatrix[i][j].get(key));\r\n                    map.put(\"lowestKey\", key);\r\n                    map.put(\"lowestI\", i);\r\n                    map.put(\"lowestJ\", j);\r\n                    map.put(\"lowestValueIsJudgement\", true);\r\n                    lowestValues.add(map);\r\n                    map = new HashMap<>();\r\n                }\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < preferenceEntropy.length; i++){\r\n            for (Object key: preferenceEntropy[i].keySet()) {\r\n                map.put(\"lowestValue\", preferenceEntropy[i].get(key));\r\n                map.put(\"lowestKey\", key);\r\n                map.put(\"lowestI\", i);\r\n                map.put(\"lowestJ\", null);\r\n                map.put(\"lowestValueIsJudgement\", false);\r\n                lowestValues.add(map);\r\n                map = new HashMap<>();\r\n            }\r\n        }\r\n\r\n        lowestValues.sort((o1, o2) -> Double.compare((Double)o1.get(\"lowestValue\"), (Double)o2.get(\"lowestValue\")));\r\n        return lowestValues;\r\n    }\r\n\r\n    private static List<List<Object>> getPreferenceCombinations(ArrayList<Object>[] aggregatedWeights){\r\n        //aggregatedWeights\r\n        List<List<Object>> fullIterationObjects2 = new ArrayList<>();\r\n        fullIterationObjects2.addAll(Arrays.asList(aggregatedWeights));\r\n\r\n        List<List<Object>> cartesianProduct2 = CartesianProduct.cartesianProduct(fullIterationObjects2);\r\n\r\n        if(aggregatedWeights[0].get(0).getClass().equals(LexPreferenzes.class)){\r\n            cartesianProduct2 = cutInvalidIterationsForLex(cartesianProduct2);\r\n        }\r\n\r\n        return cartesianProduct2;\r\n    }\r\n\r\n    private static List<List<Object>> getJudgementCombinations(ArrayList<Object>[][] aggregatedMatrix){\r\n        //aggregatedMatrix\r\n        List<List<Object>> fullIterationObjects = new ArrayList<>();\r\n        for(int i = 0; i < aggregatedMatrix.length; i++){\r\n            fullIterationObjects.addAll(Arrays.asList(aggregatedMatrix[i]));\r\n        }\r\n\r\n        long judgementCombinationNumber = 1;\r\n        int tenFactorOf = 0;\r\n        for(List<Object> lists : fullIterationObjects){\r\n            judgementCombinationNumber *= lists.size();\r\n            if(judgementCombinationNumber > 10){\r\n                judgementCombinationNumber /= 10;\r\n                tenFactorOf += 3;\r\n            }\r\n        }\r\n        if(tenFactorOf > 7){\r\n            return null;\r\n        }\r\n\r\n        return CartesianProduct.cartesianProduct(fullIterationObjects);\r\n    }\r\n\r\n    public static List<List<Object>> cutInvalidIterationsForLex(List<List<Object>> cartesianProduct2){\r\n        List<List<Object>> list = new ArrayList<>();\r\n        for(int i = 0; i < cartesianProduct2.size(); i++){\r\n            if(!hasDouble(cartesianProduct2.get(i))){\r\n                list.add(cartesianProduct2.get(i));\r\n            }\r\n        }\r\n        return list;\r\n    }\r\n\r\n    public static boolean hasDouble(List<Object> arr){\r\n        for(int j = 0; j < arr.size(); j++){\r\n            Object elem = arr.get(j);\r\n            for(int i = j + 1; i < arr.size(); i++){\r\n                if(arr.get(i).equals(elem)){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static Object[][] listToMatrix(List<Object> list, int matrixLength){\r\n        Object[][] matrix = new Object[matrixLength][list.size() / matrixLength];\r\n        int counter = 0;\r\n        for(int i = 0; i < matrix.length; i++){\r\n            for(int j = 0; j < matrix[i].length; j++){\r\n                matrix[i][j] = list.get(counter);\r\n                counter++;\r\n            }\r\n        }\r\n        return matrix;\r\n    }\r\n\r\n    public static Double getCurrentEntropy(Object[][] rankAcceptabilityIndices){\r\n        Double[] vector = new Double[rankAcceptabilityIndices.length];\r\n        for(int i = 0; i < rankAcceptabilityIndices.length; i++){\r\n            vector[i] = (Double) rankAcceptabilityIndices[i][0];\r\n        }\r\n        return calculateEntropy(vector);\r\n    }\r\n\r\n    public static  Map<Object, Double>[] getEntropyPreference(ArrayList<Map<Object, Object>[]> objectPotentialPreferenceAcceptabilityIndices){\r\n        Map<Object, Double>[] entropyMatrix = new Map[objectPotentialPreferenceAcceptabilityIndices.get(0).length];\r\n        Double[] vector = new Double[objectPotentialPreferenceAcceptabilityIndices.size()];\r\n\r\n        for(int i = 0; i < objectPotentialPreferenceAcceptabilityIndices.get(0).length; i++){\r\n            Map<Object, Double> map = new HashMap<>();\r\n            for (Map.Entry<Object, Object> entry : objectPotentialPreferenceAcceptabilityIndices.get(0)[i].entrySet()) {\r\n                for(int object = 0; object < vector.length; object++){\r\n                    vector[object] = (Double) objectPotentialPreferenceAcceptabilityIndices.get(object)[i].get(entry.getKey());\r\n                }\r\n                map.put(entry.getKey(), calculateEntropy(vector));\r\n                entropyMatrix[i] = map;\r\n            }\r\n\r\n        }\r\n\r\n        return entropyMatrix;\r\n    }\r\n\r\n    public static  Map<Object, Double>[][] getEntropyMatrix(ArrayList<Map<Object, Object>[][]> objectPotentialJudgementAcceptabilityIndices){\r\n        Map<Object, Double>[][] entropyMatrix = new Map[objectPotentialJudgementAcceptabilityIndices.get(0).length][];\r\n        Double[] vektor = new Double[objectPotentialJudgementAcceptabilityIndices.size()];\r\n\r\n        for(int i = 0; i < objectPotentialJudgementAcceptabilityIndices.get(0).length; i++){\r\n            entropyMatrix[i] = new Map[objectPotentialJudgementAcceptabilityIndices.get(0)[i].length];\r\n            for(int j = 0; j < objectPotentialJudgementAcceptabilityIndices.get(0)[i].length; j++){\r\n                Map<Object, Double> map = new HashMap<>();\r\n                for (Map.Entry<Object, Object> entry : objectPotentialJudgementAcceptabilityIndices.get(0)[i][j].entrySet()) {\r\n                    for(int object = 0; object < vektor.length; object++){\r\n                        vektor[object] = (Double) objectPotentialJudgementAcceptabilityIndices.get(object)[i][j].get(entry.getKey());\r\n                    }\r\n                    map.put(entry.getKey(), calculateEntropy(vektor));\r\n                    entropyMatrix[i][j] = map;\r\n                }\r\n            }\r\n        }\r\n\r\n        return entropyMatrix;\r\n    }\r\n\r\n    public static Double calculateEntropy(Double[] vector) {\r\n        Double entropy = 0.0;\r\n        Double sum = 0.0;\r\n\r\n        for (Double value : vector) {\r\n            sum += value;\r\n        }\r\n\r\n        for (Double value : vector) {\r\n            if (value != 0.0) {\r\n                Double probability = value / sum;\r\n                entropy -= probability * Math.log(probability) / Math.log(2);\r\n            }\r\n        }\r\n\r\n        return entropy;\r\n    }\r\n\r\n    public static void scaleAggregatedMatrixMap(ArrayList<Map<Object, Object>[][]> objectPotentialJudgementAcceptabilityIndices){\r\n        Double integer;\r\n        for(int object = 0; object < objectPotentialJudgementAcceptabilityIndices.size(); object++){\r\n            for(int i = 0; i < objectPotentialJudgementAcceptabilityIndices.get(object).length; i++){\r\n                for(int j = 0; j < objectPotentialJudgementAcceptabilityIndices.get(object)[i].length; j++){\r\n                    for (Map.Entry<Object, Object> entry : objectPotentialJudgementAcceptabilityIndices.get(object)[i][j].entrySet()) {\r\n                        integer = (Double)entry.getValue();\r\n                        integer /= (Integer) iteration;\r\n                        entry.setValue(integer);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void scaleAggregatedWeightsMap(ArrayList<Map<Object, Object>[]> objectCurrentPreferenceAcceptabilityIndices){\r\n        Double integer;\r\n        for(int object = 0; object < objectCurrentPreferenceAcceptabilityIndices.size(); object++){\r\n            for(int i = 0; i < objectCurrentPreferenceAcceptabilityIndices.get(object).length; i++){\r\n                for (Map.Entry<Object, Object> entry : objectCurrentPreferenceAcceptabilityIndices.get(object)[i].entrySet()) {\r\n                    integer = (Double)entry.getValue();\r\n                    integer /= (Integer) iteration;\r\n                    entry.setValue(integer);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void normalizeTotalRankingPositions(Object[][] totalRankingPositions){\r\n        //add values in a col to get integer /= ...\r\n        Double integer;\r\n        for(int i = 0; i < totalRankingPositions.length; i++){\r\n            for(int j = 0; j < totalRankingPositions[i].length; j++){\r\n                integer = (Double) totalRankingPositions[j][i] * 1.0;\r\n                integer /= iteration;\r\n                totalRankingPositions[j][i] = integer;\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void fillPotentialAggregatedWeightsRankingMap(ArrayList<Map<Object, Object>[]> objectCurrentPreferenceAcceptabilityIndices,\r\n                                                                ArrayList<Map<Object, Object>[]> objectPotentialPreferenceAcceptabilityIndices){\r\n        for(int object = 0; object < objectCurrentPreferenceAcceptabilityIndices.size(); object++){\r\n            for(int i = 0; i < objectCurrentPreferenceAcceptabilityIndices.get(object).length; i++) {\r\n                Integer multiplicator = objectCurrentPreferenceAcceptabilityIndices.get(object)[i].size();\r\n                for (Map.Entry<Object, Object> entry : objectPotentialPreferenceAcceptabilityIndices.get(object)[i].entrySet()) {\r\n                    entry.setValue((Double)objectCurrentPreferenceAcceptabilityIndices.get(object)[i].get(entry.getKey()) * multiplicator);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void fillPotentialJudgementAcceptabilityIndices(ArrayList<Map<Object, Object>[][]> objectCurrentJudgementAcceptabilityIndices,\r\n                                                                  ArrayList<Map<Object, Object>[][]> objectPotentialJudgementAcceptabilityIndices){\r\n        for(int object = 0; object < objectCurrentJudgementAcceptabilityIndices.size(); object++){\r\n            for(int i = 0; i < objectCurrentJudgementAcceptabilityIndices.get(object).length; i++){\r\n                for(int j = 0; j < objectCurrentJudgementAcceptabilityIndices.get(object)[i].length; j++){\r\n                    Integer multiplicator = objectCurrentJudgementAcceptabilityIndices.get(object)[i][j].size();\r\n                    for (Map.Entry<Object, Object> entry : objectPotentialJudgementAcceptabilityIndices.get(object)[i][j].entrySet()) {\r\n                        entry.setValue((Double)objectCurrentJudgementAcceptabilityIndices.get(object)[i][j].get(entry.getKey()) * multiplicator);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void countByRankingAndDecision(Object[] rankingPosition,\r\n                                                 ArrayList<Map<Object, Object>[][]> objectCurrentJudgementAcceptabilityIndices,\r\n                                                 Object[][] sawMatrix){\r\n        for(int i = 0; i < rankingPosition.length; i++){\r\n            if(Objects.equals(rankingPosition[i], 1)){\r\n                //add for rank one the counter for Judgements from saw by one\r\n                addRankOneToCJAI(i, objectCurrentJudgementAcceptabilityIndices, sawMatrix);\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public static void addRankOneToCJAI(Integer rankOne,\r\n                                        ArrayList<Map<Object, Object>[][]> objectCurrentJudgementAcceptabilityIndices,\r\n                                        Object[][] sawMatrix){\r\n        for(int i = 0; i < sawMatrix.length; i++){\r\n            for(int j = 0; j < sawMatrix[i].length; j++){\r\n                //get old value\r\n                Double value = (Double) objectCurrentJudgementAcceptabilityIndices.get(rankOne)[i][j].get(sawMatrix[i][j]);\r\n                value += 1;\r\n                //set new value\r\n                objectCurrentJudgementAcceptabilityIndices.get(rankOne)[i][j].put(sawMatrix[i][j], value);\r\n            }\r\n        }\r\n    }\r\n\r\n    public static void countByRankingAndWeights(Object[] rankingPosition, ArrayList<Map<Object, Object>[]> currentPreferenceAcceptabilityIndices, Object[] sawWeights){\r\n        Integer rankOne = null;\r\n        for(int i = 0; i < rankingPosition.length; i++){\r\n            if(Objects.equals(rankingPosition[i], 1)){\r\n                rankOne = i;\r\n            }\r\n        }\r\n        for(int i = 0; i < sawWeights.length; i++){\r\n            //get old value\r\n            Double value = (Double) currentPreferenceAcceptabilityIndices.get(rankOne)[i].get(sawWeights[i]);\r\n            value += 1;\r\n            //set new value\r\n            currentPreferenceAcceptabilityIndices.get(rankOne)[i].put(sawWeights[i], value);\r\n        }\r\n    }\r\n\r\n    public static void fillWeightsMapWithZero(ArrayList<Object>[] aggregatedWeights, Map<Object, Object>[] aggregatedWeightsRankingMap){\r\n        for(int i = 0; i < aggregatedWeights.length; i++){\r\n            //create cell\r\n            Map<Object, Object> newMap = new HashMap<>();\r\n            for(int k = 0; k < aggregatedWeights[i].size(); k++){\r\n                //set countingMap to value\r\n                newMap.put(aggregatedWeights[i].get(k), 0.0);\r\n            }\r\n            aggregatedWeightsRankingMap[i] = newMap;\r\n        }\r\n    }\r\n\r\n    public static void fillMatrixMapWithZero(ArrayList<Object>[][] aggregatedMatrix, Map<Object, Object>[][] aggregatedMatrixRankingMap){\r\n        for(int i = 0; i < aggregatedMatrix.length; i++){\r\n            for(int j = 0; j < aggregatedMatrix[i].length; j++){\r\n                //create cell\r\n                Map<Object, Object> newMap = new HashMap<>();\r\n                for(int k = 0; k < aggregatedMatrix[i][j].size(); k++){\r\n                    //set countingMap to value\r\n                    newMap.put(aggregatedMatrix[i][j].get(k), 0.0);\r\n                }\r\n                aggregatedMatrixRankingMap[i][j] = newMap;\r\n            }\r\n        }\r\n    }\r\n\r\n    @NotNull\r\n    public static ArrayList<Object>[][] generateAggregatedMatrix(@NotNull ArrayList<Object[][]> dMList){\r\n        ArrayList<Object>[][] aggregatedMatrix = new ArrayList[dMList.get(0).length][dMList.get(0)[0].length];\r\n\r\n        //fill aggregated with empty lists\r\n        for(int i = 0; i < aggregatedMatrix.length; i++){\r\n            for(int j = 0; j < aggregatedMatrix[i].length; j++){\r\n                aggregatedMatrix[i][j] = new ArrayList<>();\r\n            }\r\n        }\r\n\r\n        //fill empty lists\r\n        for (Object[][] objects : dMList) {\r\n            for (int i = 0; i < aggregatedMatrix.length; i++) {\r\n                for (int j = 0; j < dMList.get(0)[0].length; j++) {\r\n                    if (!aggregatedMatrix[i][j].contains(objects[i][j])) {\r\n                        aggregatedMatrix[i][j].add(objects[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return aggregatedMatrix;\r\n    }\r\n\r\n    @NotNull\r\n    public static ArrayList<Object>[] generateAggregatedWeights(@NotNull ArrayList<Object[]> dMWList){\r\n        ArrayList<Object>[] aggregatedWeights = new ArrayList[dMWList.get(0).length];\r\n\r\n        //fill aggregated with empty lists\r\n        for(int j = 0; j < aggregatedWeights.length; j++){\r\n            aggregatedWeights[j] = new ArrayList<>();\r\n        }\r\n\r\n        //fill empty lists\r\n        for(int k = 0; k < dMWList.size(); k++){\r\n            for(int j = 0; j < dMWList.get(0).length; j++){\r\n                if(!aggregatedWeights[j].contains(dMWList.get(k)[j])){\r\n                    aggregatedWeights[j].add(dMWList.get(k)[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return aggregatedWeights;\r\n    }\r\n\r\n    @NotNull\r\n    public static ArrayList<Object[]> generateDecisionMakerWeightList(Class<?> clazz, int number, int length, int min, int max){\r\n        ArrayList<Object[]> dMWList = new ArrayList<>();\r\n        Object[] matrix;\r\n//        System.out.println(\"Generates decisionMakerWeightList: \");\r\n        for(int i = 0; i < number; i++){\r\n            matrix = Helper.generate1DArray(clazz, length, min, max);\r\n//            Helper.show1DArray(matrix);\r\n            dMWList.add(matrix);\r\n        }\r\n\r\n        return dMWList;\r\n    }\r\n\r\n    @NotNull\r\n    public static ArrayList<Object[][]> generateDecisionMakerList(Class<?> clazz, int number, int row, int col, int min, int max){\r\n        ArrayList<Object[][]> dMList = new ArrayList<>();\r\n        Object[][] matrix;\r\n\r\n        for(int i = 0; i < number; i++){\r\n            matrix = Helper.generate2DArray(clazz, row, col, min, max);\r\n            dMList.add(matrix);\r\n        }\r\n\r\n        return dMList;\r\n    }\r\n\r\n    public static void addRanking(Object[][] totalRanking, Object[] newRanking){\r\n        Double i1;\r\n        Integer x;\r\n        for(int i = 0; i < newRanking.length; i++){\r\n            x = (Integer) newRanking[i] - 1;\r\n            i1 = (Double)totalRanking[i][x];\r\n            i1 += 1;\r\n            totalRanking[i][x] = i1;\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public static Object[] getRanksArray(Object[] array) {\r\n        Object[] result = new Object[array.length];\r\n\r\n        for (int i = 0; i < array.length; i++) {\r\n            int count = 0;\r\n            for (Object aDouble : array) {\r\n                if ((Double) aDouble > (Double) array[i]) {\r\n                    count++;\r\n                }\r\n            }\r\n            result[i] = count + 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/MonteCarloHelper.java b/src/main/java/MonteCarloHelper.java
--- a/src/main/java/MonteCarloHelper.java	(revision 2b64650cc2621ad314cb439371d936cc2b1ac45c)
+++ b/src/main/java/MonteCarloHelper.java	(date 1699393567117)
@@ -345,13 +345,17 @@
             judgementCombinationNumber *= lists.size();
             if(judgementCombinationNumber > 10){
                 judgementCombinationNumber /= 10;
-                tenFactorOf += 3;
+                tenFactorOf += 1;
             }
         }
         if(tenFactorOf > 7){
+            System.out.println(judgementCombinationNumber);
+            System.out.println(tenFactorOf);
             return null;
         }
 
+        System.out.println("normal: " + judgementCombinationNumber);
+        System.out.println("normal: " + tenFactorOf);
         return CartesianProduct.cartesianProduct(fullIterationObjects);
     }
 
Index: src/main/java/testClass.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/testClass.java b/src/main/java/testClass.java
new file mode 100644
--- /dev/null	(date 1699391541636)
+++ b/src/main/java/testClass.java	(date 1699391541636)
@@ -0,0 +1,29 @@
+import java.util.ArrayList;
+import java.util.List;
+
+public class testClass {
+    public static void main(String[] args) {
+
+        int tenFactorOf = 0;
+        int tenFactorOf2 = 0;
+        int[] list = new int[10];
+
+        long judgementCombinationNumber = 1;
+        for(int i = 0; i < list.length; i++){
+            judgementCombinationNumber *= list.length;
+            if(judgementCombinationNumber > 10){
+                System.out.println(tenFactorOf2);
+                judgementCombinationNumber /= 10;
+                tenFactorOf += 3;
+                tenFactorOf2 +=1;
+            }
+        }
+        if(tenFactorOf2 > 7){
+            System.out.println("Now " + tenFactorOf2);
+        }
+
+
+
+
+    }
+}
